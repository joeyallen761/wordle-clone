{"version":3,"sources":["script.js"],"names":["lettersPattern","currentGuessCount","currentGuess","document","querySelector","words","solutionWord","chooseWord","randomItem","Math","floor","random","length","addEventListener","e","keypress","key","test","dataset","letters","updateLetters","deleteFromLetters","submitGuess","_loop","i","setTimeout","revealTile","checkLetter","checkIfGuessComplete","checkWin","jumpTiles","_loop2","classList","add","showSolution","alert","letter","newLetters","currentTile","updateTiles","tileNumber","innerText","oldLetters","slice","deleteFromTiles","remove","position","guessedLetter","charAt","checkLetterExists","includes","state","flipTile","tileNum","tile"],"mappings":"AAAA,aACA,IAAMA,eAAiB,QACnBC,kBAAoB,EACpBC,aAAeC,SAASC,cAAc,SAAWH,mBACjDI,MAAQ,CAAC,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,SAC/DC,aAAe,GAEbC,WAAa,WAEjB,IAAIC,EAAaC,KAAKC,MAAMD,KAAKE,UAAYN,MAAMO,OAAS,IAAM,EAClEN,aAAeD,MAAMG,IAGvBD,aAIAJ,SAASU,iBAAiB,WAAW,SAACC,GAEpC,IAAIC,EAAWD,EAAEE,IACbf,kBAAoB,IAED,GAAnBc,EAASH,QACTZ,eAAeiB,KAAKH,EAAEE,MACtBd,aAAagB,QAAQC,QAAQP,OAAS,EAGtCQ,cAAcL,GACI,aAATD,EAAEE,KAAsD,IAAhCd,aAAagB,QAAQC,QAEtDE,oBACkB,SAATP,EAAEE,KAAyD,GAAvCd,aAAagB,QAAQC,QAAQP,QAC1DU,kBAKN,IAAMA,YAAc,WAElB,IAFwB,IAAAC,EAAA,SAEfC,GACPC,YAAW,WACTC,WAAWF,EAAGG,YAAYH,MACrB,IAAJA,IAHIA,EAAI,EAAGA,EAAI,EAAGA,IAAKD,EAAnBC,IAOLI,qBAAuB,SAACJ,GACnB,GAALA,GACFK,YAIEC,UAAY,WAGhB,IAHsB,IAAAC,EAAA,SAGbP,GACPC,YAAW,WACStB,SAASC,cACzB,SAAWH,kBAAoB,QAAUuB,EAAI,IAEnCQ,UAAUC,IAAI,UACrB,IAAJT,IANIA,EAAI,EAAGA,EAAI,EAAGA,IAAKO,EAAnBP,IAULK,SAAW,WAEXvB,cAAgBJ,aAAagB,QAAQC,QAGvCM,YAAW,WACTK,cACC,MAGH7B,mBAAwC,EACxCC,aAAeC,SAASC,cAAc,SAAWH,mBAExB,GAArBA,mBACFwB,YAAW,WACTS,iBACC,OAKHA,aAAe,WACnBC,MAAM,4CAA8C7B,eAIhDc,cAAgB,SAACgB,GACrB,IACIC,EADanC,aAAagB,QAAQC,QACRiB,EAC1BE,EAAcD,EAAWzB,OAC7BV,aAAagB,QAAQC,QAAUkB,EAE/BE,YAAYD,EAAaF,IAIrBG,YAAc,SAACC,EAAYJ,GAE/B,IAAIE,EAAcnC,SAASC,cACzB,SAAWH,kBAAoB,OAASuC,GAE1CF,EAAYG,UAAYL,EACxBE,EAAYN,UAAUC,IAAI,eAItBZ,kBAAoB,WAExB,IAAIqB,EAAaxC,aAAagB,QAAQC,QAElCkB,EAAaK,EAAWC,MAAM,GAAI,GAEtCzC,aAAagB,QAAQC,QAAUkB,EAC/BO,gBAAgBF,EAAW9B,SAIvBgC,gBAAkB,SAACJ,GAGvB,IAAIF,EAAcnC,SAASC,cACzB,SAAWH,kBAAoB,OAASuC,GAE1CF,EAAYG,UAAY,GACxBH,EAAYN,UAAUa,OAAO,eAKzBlB,YAAc,SAACmB,GAEnB,IAAIC,EAAgB7C,aAAagB,QAAQC,QAAQ6B,OAAOF,GAKxD,OAAIC,GAJiBzC,aAAa0C,OAAOF,GAKhC,UAIAG,kBAAkBF,GAAiB,UAAY,UAMpDE,kBAAoB,SAACb,GACzB,OAAO9B,aAAa4C,SAASd,IAGzBV,WAAa,SAACF,EAAG2B,GAGrBC,SADc5B,EAAI,EACA2B,GAClBvB,qBAAqBJ,IAGjB4B,SAAW,SAACC,EAASF,GACzB,IAAIG,EAAOnD,SAASC,cAClB,SAAWH,kBAAoB,OAASoD,GAE1CC,EAAKtB,UAAUC,IAAI,WACnBR,YAAW,WACT6B,EAAKtB,UAAUC,IAAIkB,KAClB,KACH1B,YAAW,WACT6B,EAAKtB,UAAUa,OAAO,WACtBS,EAAKtB,UAAUC,IAAI,cAClB,KACHR,YAAW,WACT6B,EAAKtB,UAAUa,OAAO,cACrB","file":"script.js","sourcesContent":["//console.log('keypress');\nconst lettersPattern = /[a-z]/; // /^[A-Za-z][A-Za-z0-9]*$/;\nlet currentGuessCount = 1;\nlet currentGuess = document.querySelector('#guess' + currentGuessCount);\nlet words = ['apple', 'baker', 'store', 'horse', 'speak', 'clone', 'bread'];\nlet solutionWord = '';\n\nconst chooseWord = () => {\n  // choose random item from words array\n  let randomItem = Math.floor(Math.random() * (words.length - 1)) + 1;\n  solutionWord = words[randomItem];\n};\n\nchooseWord();\n//console.log('solution word = ' + solutionWord);\n\n// detect keypress (letter, backspace, enter, other)\ndocument.addEventListener('keydown', (e) => {\n  //console.log('keypress: ' + e.key);\n  let keypress = e.key;\n  if (currentGuessCount < 7) {\n    if (\n      keypress.length == 1 &&\n      lettersPattern.test(e.key) &&\n      currentGuess.dataset.letters.length < 5\n    ) {\n      //console.log('is letter');\n      updateLetters(keypress);\n    } else if (e.key == 'Backspace' && currentGuess.dataset.letters != '') {\n      //console.log('is backspace');\n      deleteFromLetters();\n    } else if (e.key == 'Enter' && currentGuess.dataset.letters.length == 5) {\n      submitGuess();\n    }\n  }\n});\n\nconst submitGuess = () => {\n  //console.log('submit guess');\n  for (let i = 0; i < 5; i++) {\n    setTimeout(() => {\n      revealTile(i, checkLetter(i));\n    }, i * 200);\n  }\n};\n\nconst checkIfGuessComplete = (i) => {\n  if (i == 4) {\n    checkWin();\n  }\n};\n\nconst jumpTiles = () => {\n  //console.log('jumpTiles');\n  //console.log(currentGuessCount);\n  for (let i = 0; i < 5; i++) {\n    setTimeout(() => {\n      let currentTile = document.querySelector(\n        '#guess' + currentGuessCount + 'Tile' + (i + 1)\n      );\n      currentTile.classList.add('jump');\n    }, i * 200);\n  }\n};\n\nconst checkWin = () => {\n  //console.log('check win');\n  if (solutionWord == currentGuess.dataset.letters) {\n    // Win\n    //console.log('game is won!');\n    setTimeout(() => {\n      jumpTiles();\n    }, 500);\n  } else {\n    // Not won\n    currentGuessCount = currentGuessCount + 1;\n    currentGuess = document.querySelector('#guess' + currentGuessCount);\n    //console.log('not a win, increment guess count to ' + currentGuessCount);\n    if (currentGuessCount == 7) {\n      setTimeout(() => {\n        showSolution();\n      }, 500);\n    }\n  }\n};\n\nconst showSolution = () => {\n  alert('Better luck next time. The solution was: ' + solutionWord);\n};\n\n// Update \"letters\"\nconst updateLetters = (letter) => {\n  let oldLetters = currentGuess.dataset.letters;\n  let newLetters = oldLetters + letter;\n  let currentTile = newLetters.length;\n  currentGuess.dataset.letters = newLetters;\n  //console.log('currentTile = ' + currentTile);\n  updateTiles(currentTile, letter);\n};\n\n// Update tile markup\nconst updateTiles = (tileNumber, letter) => {\n  //console.log('updateTiles(' + tileNumber, letter + ')');\n  let currentTile = document.querySelector(\n    '#guess' + currentGuessCount + 'Tile' + tileNumber\n  );\n  currentTile.innerText = letter;\n  currentTile.classList.add('has-letter');\n};\n\n// Backspace -- Delete last letter\nconst deleteFromLetters = () => {\n  // remove last letter from data-letters\n  let oldLetters = currentGuess.dataset.letters;\n  //console.log('oldLetters = ' + oldLetters);\n  let newLetters = oldLetters.slice(0, -1);\n  //console.log('newLetters = ' + newLetters);\n  currentGuess.dataset.letters = newLetters;\n  deleteFromTiles(oldLetters.length);\n};\n\n// Backspace -- Delete last tile markup\nconst deleteFromTiles = (tileNumber) => {\n  // remove markup from last tile\n  //console.log('deleteFromTiles = ' + tileNumber);\n  let currentTile = document.querySelector(\n    '#guess' + currentGuessCount + 'Tile' + tileNumber\n  );\n  currentTile.innerText = '';\n  currentTile.classList.remove('has-letter');\n};\n\n// Check letter to solution\n// parameter = letter position in word\nconst checkLetter = (position) => {\n  //console.log('checkLetter');\n  let guessedLetter = currentGuess.dataset.letters.charAt(position);\n  let solutionLetter = solutionWord.charAt(position);\n  //console.log(guessedLetter, solutionLetter);\n\n  // If letters match, return \"correct\"\n  if (guessedLetter == solutionLetter) {\n    return 'correct';\n  }\n  // If not a match, if letter exists in solution word, return \"present\"\n  else {\n    return checkLetterExists(guessedLetter) ? 'present' : 'absent';\n  }\n\n  // If not a match, if letter doesn't exist in solution, return \"absent\"\n};\n\nconst checkLetterExists = (letter) => {\n  return solutionWord.includes(letter);\n};\n\nconst revealTile = (i, state) => {\n  //console.log('revealTile = ' + i, state);\n  let tileNum = i + 1;\n  flipTile(tileNum, state);\n  checkIfGuessComplete(i);\n};\n\nconst flipTile = (tileNum, state) => {\n  let tile = document.querySelector(\n    '#guess' + currentGuessCount + 'Tile' + tileNum\n  );\n  tile.classList.add('flip-in');\n  setTimeout(() => {\n    tile.classList.add(state);\n  }, 250);\n  setTimeout(() => {\n    tile.classList.remove('flip-in');\n    tile.classList.add('flip-out');\n  }, 250);\n  setTimeout(() => {\n    tile.classList.remove('flip-out');\n  }, 1500);\n};\n/*\n- if keypress is a letter\n  - update \"letters\" attribute\n    - update tile markup based on \"letters\" value\n- if keypress is backspace\n  - delete last letter in \"letters\"\n    - update tile markup based on \"letters\"\n*/\n"]}